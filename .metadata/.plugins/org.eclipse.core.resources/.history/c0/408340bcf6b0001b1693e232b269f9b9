/**
* Name: clustering
* Based on the internal empty template. 
* Author: Juan MÃºgica
* Tags: 
*/


model clustering

import "./Agents.gaml"
import "./Parameters.gaml"

global {
	date starting_date <- #now;
	//---------------------------------------------------------Performance Measures-----------------------------------------------------------------------------
	int randomID;
	//-------------------------------------------------------------------Necessary Variables--------------------------------------------------------------------------------------------------

    float step <- 10 #mn;
    int current_hour update: (time / #hour) mod 24;
	//Implement a reflex to update current day. See City Scope Main. TBD
	int current_day <- 0;
	
	
 	string cityScopeCity<-"UrbanSwarm";
 	//string cityScopeCity<-"clustering";
	string cityGISFolder <- "./../../includes/City/"+cityScopeCity;
	// GIS FILES
	/*file bound_shapefile <- file(cityGISFolder + "/BOUNDARY_CityBoundary.shp");
	file buildings_shapefile <- file(cityGISFolder + "/CDD_LandUse.shp");
	//file roads_shapefile <- file(cityGISFolder + "/BASEMAP_Roads.shp");
	file roads_shapefile <- file(cityGISFolder + "/Roads_new.shp");
	file instersections_shapefile <- file(cityGISFolder + "/TRANS_Intersections.shp");
	file driveways_shapefile <- file(cityGISFolder + "/BASEMAP_Driveways.shp");*/
	//file majorRoads_shapefile <- file(cityGISFolder + "/TRANS_MajorRoads.shp");
	file bound_shapefile <- file(cityGISFolder + "/Bounds.shp");
	file buildings_shapefile <- file(cityGISFolder + "/Buildings.shp");
	file roads_shapefile <- file(cityGISFolder + "/Roads.shp");
	file imageRaster <- file('./../../images/gama_black.png');
	geometry shape <- envelope(bound_shapefile);
	//file dockingStations <- file(cityGISFolder + "/dockingStations.shp");
	//file dockingStations <- file("./../../includes/City/clustering" + "/dockingStations.shp");
    int nb_docking;
    int min_work_start <- 6;
    int max_work_start <- 8;
    int min_work_end <- 16; 
    int max_work_end <- 20; 
    float min_speed <- 1.0 #km / #h;
    float max_speed <- 5.0 #km / #h; 
    graph the_graph;
    //rgb backgroundColor<-#white;
    map<string, rgb> color_map <- ["R"::#white, "O"::#gray, "Other"::#black];
    //map<string, rgb> color_map <- ["Residential"::#white, "Office"::#gray, "Other"::#black];
	

	//-------------------------------------Species Creation-----------------------------------------------------------------------------------------------------------------------
    
    init {
		//---------------------------------------------------PERFORMANCE-----------------------------------------------    	
		randomID <- rnd (10000);
	    //Juan: Adapt this depending on GIS data
	    /*create building from: buildings_shapefile with: [type::string(read ("Category"))] {
	    		if(type!="Office" and type!="Residential"){
	    			type <- "Other";
	    		}
	        }*/
	    create building from: buildings_shapefile with: [type::string(read ("Usage"))] {
	    		if(type!="O" and type!="R"){
	    			type <- "Other";
	    		}
	        }
	    
	    create road from: roads_shapefile ; 
	    the_graph <- as_edge_graph(road);
	    
		//------------------------------------------BIKE SPECIES-------------------------------------------------------------			
	    
	 
		// ---------------------------------------The Road Network----------------------------------------------
		create pheromoneRoad from: roads_shapefile{
			pheromone <- 0.0;
		}
		
		//Juan: is this roadNetwork necessary? Having already the_graph
		//roadNetwork <- as_edge_graph(pheromoneRoad) ;
		roadNetwork <- as_edge_graph(pheromoneRoad) ;   
		// Next move to the shortest path between each point in the graph
		matrix allPairs <- all_pairs_shortest_path (roadNetwork);    
	    
		// -------------------------------------Location of the charging stations----------------------------------------   
		
		loop i from: 0 to: length(roadNetwork.vertices) - 1 {
			create intersection {
			location <- point (roadNetwork.vertices[i]);
		}
		}
		//K-Means		
		//Create a list of list containing for each vertice a list composed of its x and y values
		list<list> instances <- intersection collect ([each.location.x, each.location.y]);

			
			
		//from the vertices list, create k groups  with the Kmeans algorithm (https://en.wikipedia.org/wiki/K-means_clustering)
		list<list<int>> clusters_kmeans <- list<list<int>>(kmeans(instances, dockingNum));

		//from clustered vertices to centroids locations
		int groupIndex <- 0;
		list<point> coordinatesCentroids <- [];
		loop cluster over: clusters_kmeans {
			groupIndex <- groupIndex + 1;
				list<point> coordinatesVertices <- [];
				loop i over: cluster {
					add point (roadNetwork.vertices[i]) to: coordinatesVertices; 
				}
			add mean(coordinatesVertices) to: coordinatesCentroids;
		}    
	    
	    //from docking locations to closest intersection
	    list<int> tmpDist;

		loop centroid from:0 to:length(coordinatesCentroids)-1 {
			tmpDist <- [];
			loop vertices from:0 to:length(roadNetwork.vertices)-1{
				add (point(roadNetwork.vertices[vertices]) distance_to coordinatesCentroids[centroid]) to: tmpDist;					
			}	
			loop vertices from:0 to: length(tmpDist)-1{
				if(min(tmpDist)=tmpDist[vertices]){
					add vertices to: dockingLocation;
					break;
				}
			}	
		}
	    
	    //Juan: for docking stations obtaind from file
	    /*create docking from: dockingStations ;
	    loop station from:0 to:length(docking)-1 {
	    	tmpDist <- [];
	    	loop vertice from:0 to:length(roadNetwork.vertices)-1{
	    		add (point(roadNetwork.vertices[vertice])) distance_to docking[station].location to: tmpDist;
	    	}
	    	loop vertice from:0 to: length(tmpDist)-1{
	    		if(min(tmpDist)=tmpDist[vertice]){
	    			add vertice to: dockingLocation;
	    			break;
	    		}
	    	}
	    }
	    
	    //Asign docking locations the new locations
	    loop station from:0 to:length(docking)-1 {
	    	docking[station].location <- roadNetwork.vertices[dockingLocation[station]];
	    }*/
	    loop i from: 0 to: length(dockingLocation) - 1 {
			create docking{
				location <- point(roadNetwork.vertices[dockingLocation[i]]);
			}
		}
		
	    
		// -------------------------------------------The Bikes -----------------------------------------
		create bike number:bikeNum{						
					location <- point(one_of(roadNetwork.vertices)); 
					target <- location; 
					source <- location;
					carrying <- false;
					lowBattery <- false;
					speedDist <- 1.0;
					pheromoneToDiffuse <- 0.0;
					pheromoneMark <- 0.0;
					batteryLife <- rnd(maxBatteryLife);
					speedDist <- maxSpeedDist;
				}
	    
	    //list<building> residential_buildings <- building where (each.type="Residential");
	    list<building> residential_buildings <- building where (each.type="R");
	    //list<building> office_buildings <- building where (each.type="Office");
	    list<building> office_buildings <- building where (each.type="O");
	    create people number: nb_people {
	        speed <- rnd(min_speed, max_speed);
	        start_work <- rnd (min_work_start, max_work_start);
	        end_work <- rnd(min_work_end, max_work_end);
	        living_place <- one_of(residential_buildings) ;
	        working_place <- one_of(office_buildings) ;
	        objective <- "resting";
	        location <- any_location_in (one_of (residential_buildings));
	    }
	 	// ----------------------------------The RFIDs tag on each road intersection------------------------
		//loop i from: 0 to: length(roadNetwork.vertices) - 1 {
		loop i from: 0 to: length(roadNetwork.vertices) - 1 {
			create tagRFID{ 								
				id <- i;
				checked <- false;					
				location <- point(roadNetwork.vertices[i]); 
				pheromones <- [0.0,0.0,0.0,0.0,0.0];
				pheromonesToward <- neighbors_of(roadNetwork,roadNetwork.vertices[i]);  //to know what edge is related  to that amount of pheromone
				
				// Find the closest chargingPoint and set towardDocking and distanceToDocking
				/*ask docking closest_to self {
					myself.distanceToDocking <- int(point(roadNetwork.vertices[i]) distance_to self.location);
					loop y from: 0 to: length(dockingLocation) - 1 {
						if (point(roadNetwork.vertices[dockingLocation[y]]) = self.location){
							//Assign next vertice to closest docking
							myself.towardDocking <- point(roadNetwork.vertices[allPairs[dockingLocation[y],i]]);
							//Juan: I don't understand this last statement
							if (myself.towardDocking=point(roadNetwork.vertices[i])){
								myself.towardDocking <- point(roadNetwork.vertices[dockingLocation[y]]);
							}
							break;
						}				
					}					
				}				
				type <- 'roadIntersection';				
				loop y from: 0 to: length(dockingLocation) - 1 {
					if (i=dockingLocation[y]){
						type <- 'Docking&roadIntersection';
					}
				}*/	
								
			}
		}
		


	        
    }
}

species building {
    string type; 
    rgb color <- #black  ;
    
    aspect base {
    draw shape color: color ;
    }
    
    aspect default {
		draw shape color: rgb(50, 50, 50, 125);
	}
    
    aspect type{
		draw shape color: color_map[type];
	}
}

species road  {
    rgb color <- #black ;
    aspect base {
       draw shape color: rgb(125, 125, 125);
    }
}


experiment clustering type: gui {
    parameter "Shapefile for the buildings:" var: buildings_shapefile category: "GIS" ;
    parameter "Shapefile for the roads:" var: roads_shapefile category: "GIS" ;
    parameter "Shapefile for the bounds:" var: bound_shapefile category: "GIS" ;
    parameter "Number of people agents:" var: nb_people category: "People" ;
    parameter "Number of charging points:" var: dockingNum category: "Docking" ;
    parameter "Earliest hour to start work" var: min_work_start category: "People" min: 2 max: 8;
    parameter "Latest hour to start work" var: max_work_start category: "People" min: 8 max: 12;
    parameter "Earliest hour to end work" var: min_work_end category: "People" min: 12 max: 16;
    parameter "Latest hour to end work" var: max_work_end category: "People" min: 16 max: 23;
    parameter "minimal speed" var: min_speed category: "People" min: 0.1 #km/#h ;
    parameter "maximal speed" var: max_speed category: "People" max: 10 #km/#h;
        
    output {
    display city_display type:opengl background: #black draw_env: false{	
        species building aspect: type ;
        species pheromoneRoad aspect: base ;
        //species tagRFID aspect: base ;
        //species people aspect: base ;
        species docking aspect: base ;
        species bike aspect: base ; 
        //species intersection aspect: base ;
        graphics "text" {
				draw "day" + string(current_day) + " - " + string(current_hour) + "h" color: #white font: font("Helvetica", 25, #italic) at:
				{world.shape.width * 0.8, world.shape.height * 0.975};
				draw imageRaster size: 40 #px at: {world.shape.width * 0.95, world.shape.height * 0.95};
			}
    }
    }
}